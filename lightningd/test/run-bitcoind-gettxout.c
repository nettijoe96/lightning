#include <ccan/mem/mem.h>
#include <lightningd/log.h>
#include <stdarg.h>
#include <stdio.h>

#define fatal test_fatal

static void test_fatal(const char *fmt, ...)
{
	va_list ap;

	va_start(ap, fmt);
	vfprintf(stderr, fmt, ap);
	va_end(ap);
	exit(1);
}

  #include "../bitcoind.c"

/* AUTOGENERATED MOCKS START */
/* Generated stub for db_begin_transaction_ */
void db_begin_transaction_(struct db *db UNNEEDED, const char *location UNNEEDED)
{ fprintf(stderr, "db_begin_transaction_ called!\n"); abort(); }
/* Generated stub for db_commit_transaction */
void db_commit_transaction(struct db *db UNNEEDED)
{ fprintf(stderr, "db_commit_transaction called!\n"); abort(); }
/* Generated stub for log_ */
void log_(struct log *log UNNEEDED, enum log_level level UNNEEDED, const char *fmt UNNEEDED, ...)

{ fprintf(stderr, "log_ called!\n"); abort(); }
/* AUTOGENERATED MOCKS END */

static const char response[] = "{\n"
"  \"bestblock\": \"000000002c8efcdee064d8b95851c2d1c15166494be677af896ee7883dac0453\",\n"
"  \"confirmations\": 28806,\n"
"  \"value\": 0.05208652,\n"
"  \"scriptPubKey\": {\n"
"    \"asm\": \"0 6b1863b85e09f2ae822192c7cbb72a8f8d54d165dfea01be140f8a385a7110e0\",\n"
"    \"hex\": \"00206b1863b85e09f2ae822192c7cbb72a8f8d54d165dfea01be140f8a385a7110e0\",\n"
"    \"type\": \"witness_v0_scripthash\"\n"
"  },\n"
"  \"coinbase\": false\n"
"}";

static void test_callback(struct bitcoind *bitcoind,
			  const struct bitcoin_tx_output *output,
			  void *arg)
{
	size_t slen = strlen("00206b1863b85e09f2ae822192c7cbb72a8f8d54d165dfea01be140f8a385a7110e0");
	u8 *outscript = tal_arr(NULL, u8, hex_data_size(slen));

	if (!hex_decode("00206b1863b85e09f2ae822192c7cbb72a8f8d54d165dfea01be140f8a385a7110e0", slen, outscript, tal_len(outscript)))
		abort();
	assert(output->amount == 5208652);
	assert(memeq(output->script, tal_len(output->script),
		     outscript, tal_len(outscript)));
	tal_free(outscript);
}

int main(int argc, char *argv[])
{
	struct bitcoin_cli *bcli = tal(NULL, struct bitcoin_cli);
	struct get_output *go = tal(bcli, struct get_output);

	bcli->cb = test_callback;
	bcli->cb_arg = go;
	bcli->args = tal_arrz(bcli, char *, 2);
	bcli->args[0] = argv[0];

	bcli->exitstatus = tal(bcli, int);
	*bcli->exitstatus = 0;

	bcli->output = tal_strdup(bcli, response);
	bcli->output_bytes = strlen(response);
	process_gettxout(bcli);

	tal_free(bcli);
	exit(0);
}
